{
    "introduction": "Reinforcement learning (RL) is an area of machine learning concerned with how software agents ought to take actions in an environment in order to maximize the notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongside supervised learning and unsupervised learning. \u2022 Reinforcement learning differs from supervised learning in not needing labelled input/output pairs be presented, and in not needing sub-optimal actions to be explicitly corrected. Instead the focus is on finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge). \u2022 The environment is typically stated in the form of a Markov decision process (MDP), because many reinforcement learning algorithms for this context use dynamic programming techniques. The main difference between the classical dynamic programming methods  and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the MDP and they target large MDPs where exact methods become infeasible.",
    "Introduction": " Due to its generality, reinforcement learning is studied in many disciplines, such as game theory, control theory, operations research, information theory, simulation-based optimization, multi-agent systems, swarm intelligence, and statistics. In the operations research and control literature, reinforcement learning is called approximate dynamic programming, or neuro-dynamic programming. The problems of interest in reinforcement learning have also been studied in the theory of optimal control, which is concerned mostly with the existence and characterization of optimal solutions, and algorithms for their exact computation, and less with learning or approximation, particularly in the absence of a mathematical model of the environment. In economics and game theory, reinforcement learning may be used to explain how equilibrium may arise under bounded rationality.",
    "Exploration": " The exploration vs. exploitation trade-off has been most thoroughly studied through the multi-armed bandit problem and for finite state space MDPs in Burnetas and Katehakis (1997).Reinforcement learning requires clever exploration mechanisms; randomly selecting actions, without reference to an estimated probability distribution, shows poor performance. However, due to the lack of algorithms that scale well with the number of states (or scale to problems with infinite state spaces), simple exploration methods are the most practical. One such method is                         \u03b5                 {\\displaystyle \\varepsilon }   -greedy, where                         0         <         \u03b5         <         1                 {\\displaystyle 0<\\varepsilon <1}    is a parameter controlling the amount of exploration vs. exploitation. With probability                         1         \u2212         \u03b5                 {\\displaystyle 1-\\varepsilon }   , exploitation is chosen, and the agent chooses the action that it believes has the best long-term effect (ties between actions are broken uniformly at random). Alternatively, with probability                         \u03b5                 {\\displaystyle \\varepsilon }   , exploration is chosen, and the action is chosen uniformly at random. \u03b5                 {\\displaystyle \\varepsilon }    is usually a fixed parameter but can be adjusted either according to a schedule (making the agent explore progressively less), or adaptively based on heuristics.",
    "Algorithms for control learning": " Even if the issue of exploration is disregarded and even if the state was observable (assumed hereafter), the problem remains to use past experience to find out which actions lead to higher cumulative rewards.",
    "Criterion of optimality": " Policy The agent`s action selection is modeled as a map called policy:",
    "State-value function": " Value function                                    V                        \u03c0                             (         s         )                 {\\displaystyle V_{\\pi }(s)}    is defined as the expected return starting with state                         s                 {\\displaystyle s}   , i.e. s                        0                             =         s                 {\\displaystyle s_{0}=s}   , and successively following policy                         \u03c0                 {\\displaystyle \\pi }   . Hence, roughly speaking, the value function estimates `how good` it is to be in a given state.",
    "Brute force": " The brute force approach entails two steps:",
    "Value function": " Value function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy (usually either the `current` [on-policy] or the optimal [off-policy] one). These methods rely on the theory of MDPs, where optimality is defined in a sense that is stronger than the above one: A policy is called optimal if it achieves the best expected return from any initial state (i.e., initial distributions play no role in this definition). Again, an optimal policy can always be found amongst stationary policies. To define optimality in a formal manner, define the value of a policy                         \u03c0                 {\\displaystyle \\pi }    by",
    "Monte Carlo methods": " Policy iteration consists of two steps: policy evaluation and policy improvement. Monte Carlo is used in the policy evaluation step. In this step, given a stationary, deterministic policy                         \u03c0                 {\\displaystyle \\pi }   , the goal is to compute the function values                                    Q                        \u03c0                             (         s         ,         a         )                 {\\displaystyle Q^{\\pi }(s,a)}    (or a good approximation to them) for all state-action pairs                         (         s         ,         a         )                 {\\displaystyle (s,a)}   . Assuming (for simplicity) that the MDP is finite, that sufficient memory is available to accommodate the action-values and that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair                         (         s         ,         a         )                 {\\displaystyle (s,a)}    can be computed by averaging the sampled returns that originated from                         (         s         ,         a         )                 {\\displaystyle (s,a)}    over time. Given sufficient time, this procedure can thus construct a precise estimate                         Q                 {\\displaystyle Q}    of the action-value function                                    Q                        \u03c0                                     {\\displaystyle Q^{\\pi }}   . In the policy improvement step, the next policy is obtained by computing a greedy policy with respect to                         Q                 {\\displaystyle Q}   : Given a state                         s                 {\\displaystyle s}   , this new policy returns an action that maximizes                         Q         (         s         ,         \u22c5         )                 {\\displaystyle Q(s,\\cdot )}   .",
    "Temporal difference methods": " The first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. Most current algorithms do this, giving rise to the class of generalized policy iteration algorithms. Many actor critic methods belong to this category. The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton`s temporal difference (TD) methods that are based on the recursive Bellman equation. The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method, may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue. In order to address the fifth issue, function approximation methods are used. Linear function approximation starts with a mapping                         \u03d5                 {\\displaystyle \\phi }    that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair                         (         s         ,         a         )                 {\\displaystyle (s,a)}    are obtained by linearly combining the components of                         \u03d5         (         s         ,         a         )                 {\\displaystyle \\phi (s,a)}    with some weights                         \u03b8                 {\\displaystyle \\theta }   :",
    "Direct policy search": " An alternative method is to search directly in (some subset of) the policy space, in which case the problem becomes a case of stochastic optimization. The two approaches available are gradient-based and gradient-free methods. Gradient-based methods (policy gradient methods) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vector                         \u03b8                 {\\displaystyle \\theta }   , let                                    \u03c0                        \u03b8                                     {\\displaystyle \\pi _{\\theta }}    denote the policy associated to                         \u03b8                 {\\displaystyle \\theta }   .",
    "Theory": " Both the asymptotic and finite-sample behavior of most algorithms is well understood. Algorithms with provably good online performance (addressing the exploration issue) are known. Efficient exploration of MDPs is given in  Burnetas and Katehakis (1997). Finite-time performance bounds have also appeared for many algorithms, but these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations. For incremental algorithms, asymptotic convergence issues have been settled. Temporal-difference-based algorithms converge under a wider set of conditions than was previously possible (for example, when used with arbitrary, smooth function approximation).",
    "Research": " Research topics include",
    "Comparison of reinforcement learning algorithms": " Associative reinforcement learning Associative reinforcement learning tasks combine facets of stochastic learning automata tasks and supervised learning pattern classification tasks. In associative reinforcement learning tasks, the learning system interacts in a closed loop with its environment.",
    "Deep reinforcement learning": " This approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space. The work on learning ATARI games by Google DeepMind increased attention to deep reinforcement learning or end-to-end reinforcement learning.",
    "Inverse reinforcement learning": " In inverse reinforcement learning (IRL), no reward function is given. Instead, the reward function is inferred given an observed behavior from an expert. The idea is to mimic observed behavior, which is often optimal or close to optimal.",
    "Safe Reinforcement Learning": " Safe Reinforcement Learning (SRL) can be defined as the process of learning policies that maximize the expectation of the return in problems in which it is important to ensure reasonable system performance and/or respect safety constraints during the learning and/or deployment processes.",
    "See also": " References Further reading Auer, Peter; Jaksch, Thomas; Ortner, Ronald (2010). `Near-optimal regret bounds for reinforcement learning`. Journal of Machine Learning Research. 11: 1563\u20131600. Busoniu, Lucian; Babuska, Robert; De Schutter, Bart; Ernst, Damien (2010). Reinforcement Learning and Dynamic Programming using Function Approximators. Taylor & Francis CRC Press. ISBN 978-1-4398-2108-4. Fran\u00e7ois-Lavet, Vincent; Henderson, Peter; Islam, Riashat; Bellemare, Marc G.; Pineau, Joelle (2018). `An Introduction to Deep Reinforcement Learning`. Foundations and Trends in Machine Learning. 11 (3\u20134): 219\u2013354. arXiv:1811.12560. Bibcode:2018arXiv181112560F. doi:10.1561/2200000071. S2CID 54434537. Powell, Warren (2007). Approximate dynamic programming: solving the curses of dimensionality. Wiley-Interscience. ISBN 978-0-470-17155-4. Sutton, Richard S.; Barto, Andrew G. (2018). Reinforcement Learning: An Introduction (2 ed.). MIT Press. ISBN 978-0-262-03924-6. Sutton, Richard S. (1988). `Learning to predict by the method of temporal differences`. Machine Learning. 3: 9\u201344. doi:10.1007/BF00115009. Szita, Istvan; Szepesvari, Csaba (2010). `Model-based Reinforcement Learning with Nearly Tight Exploration Complexity Bounds` (PDF). ICML 2010. Omnipress. pp. 1031\u20131038. Archived from the original (PDF) on 2010-07-14.",
    "External links": " Reinforcement Learning Repository Reinforcement Learning and Artificial Intelligence (RLAI, Rich Sutton`s lab at the University of Alberta) Autonomous Learning Laboratory (ALL, Andrew Barto`s lab at the University of Massachusetts Amherst) Hybrid reinforcement learning Real-world reinforcement learning experiments at Delft University of Technology Stanford University Andrew Ng Lecture on Reinforcement Learning Dissecting Reinforcement Learning Series of blog post on RL with Python code"
}